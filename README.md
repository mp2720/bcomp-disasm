## ЛР 2, 3

Для работы `ocr.py` надо установить `PIL`:

```bash
pip install pillow
```

Программа даётся в виде картинки с машинным кодом. Для считывания текста нужно выполнить команду
```bash
./ocr.py VARIANT.png OUTPUT_TEXT
```

Затем программу можно дизассемблировать так:
```bash
./disas.py OUTPUT_TEXT -f=lab
```

По умолчанию дизассемблер выводит программу в виде, совместимом с ассебмлером БЭВМ.
Дополнительные опции `-a` и `-b` дают больше полезной информации, но ассемблер такое не примет.

Полный список опций можно посмотреть так
```bash
./disas.py -h
```

Дизассемблер вставит нумерованные метки на **все** адреса, которые встречаются в качестве операндов
инструкций.

Код и данные программы БЭВМ хранятся в одной памяти и дизассемблер не может их отличить друг от друга,
поэтому он пытается разобрать все слова. Если какое-то слово вообще не может быть инструкцией для
базовой микропрограммы, то в вывод будет вставлена псевдоинструкция ассемблера `WORD 0xXXXX`.

Тем не менее, даже если какое-то слово было ошибочно воспринято как инструкция, при компиляции
того, что вывел дизассемблер, на выходе получится программа, идентичная изначальной.

Ещё дизассемблер не вставляет метку `START`. Если я правильно понял, то она должна быть там, где
на картинке варианта стоит `+`.

Про ассемблер можно прочитать в Приложении Д методических указаний на
https://se.ifmo.ru/courses/csbasics

